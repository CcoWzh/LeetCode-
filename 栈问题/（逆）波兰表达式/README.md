# 波兰式、逆波兰式与表达式求值

《数据结构》中关于栈的解释经常会涉及到逆波兰式，波兰式，中缀式表达式的求值问题。这里，就对其一探究竟。

### 中缀表达式

人类最熟悉的一种表达式1+2，$(1+2)*3$，$3+4*2+4$ 等等都是中缀表示法。对于人们来说，也是最直观的一种求值方式，先算括号里的，然后算乘除，最后算加减。

但是，计算机处理中缀表达式却并不方便，因为没有一种简单的数据结构可以方便从一个表达式中间抽出
一部分算完结果，再放进去，然后继续后面的计算（链表也许可以，但是，代价也是不菲）。
在介绍前缀，后缀表达式之前，我想先通过我们最熟悉的中缀表达式画出一棵语法树来直观认识前后缀表达式。以$A+B*(C-D)-E*F$为例子：

![img](https://img-blog.csdn.net/20140304145300156?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlucmFpc2U=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

则中缀表达式得名于它是由相应的语法树的中序遍历的结果得到的。

### 中缀表达式转后缀表达式

```go
1. 从左往右扫描中缀表达式

2. 如果是数字那么将其直接入栈到数组num中

3. 如果是操作数，需要进一步判断
   1) 如果是左括号'('直接入栈到数组opera中
   2）如果是运算符（'+'、'-'、'*'、'/'），先判断数组opera的栈顶的操作数的优先级（如果是空栈那么直接入栈到数组opera），如果是左括号那么直接入栈到数组opera中，如果栈顶是运算符，且栈顶运算符的优先级大于该运算符
   那么将栈顶的运算符出栈，并入栈到数组num中，重复步骤3，如果栈顶运算符优先级小于该运算符，那么直接将该运算符入栈到opera中
   3）如果是右括号')'，那么说明在opera数组中一定有一个左括号与之对应（在你没输错的情况下），那么将opera中的运算符依次出栈，并入栈到num中，直到遇到左括号'('（注意左括号不用入栈到num）

4. 如果中缀表达式扫描完了，那么将opera中的操作数依次出栈，并入栈到num中就可以了，如果没有没有扫描完重复1-3步
```



### 例题

#### [150. 逆波兰表达式求值](https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/)

根据[逆波兰表示法](https://baike.baidu.com/item/逆波兰式/128437)，求表达式的值。

有效的运算符包括 `+`, `-`, `*`, `/` 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。

**说明：**

- 整数除法只保留整数部分。
- 给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。

**示例 1：**

```go
输入: ["2", "1", "+", "3", "*"]
输出: 9
解释: ((2 + 1) * 3) = 9
```

**示例 2：**

```go
输入: ["4", "13", "5", "/", "+"]
输出: 6
解释: (4 + (13 / 5)) = 6
```

**示例 3：**

```go
输入: ["10", "6", "9", "3", "+", "-11", "*", "/", "*", "17", "+", "5", "+"]
输出: 22
解释: 
  ((10 * (6 / ((9 + 3) * -11))) + 17) + 5
= ((10 * (6 / (12 * -11))) + 17) + 5
= ((10 * (6 / -132)) + 17) + 5
= ((10 * 0) + 17) + 5
= (0 + 17) + 5
= 17 + 5
= 22
```





### 参考文献

- [波兰式、逆波兰式与表达式求值](https://blog.csdn.net/linraise/article/details/20459751)

- [逆波兰表达式——中缀表达式转后缀表达式](https://www.cnblogs.com/lanhaicode/p/10776166.html)