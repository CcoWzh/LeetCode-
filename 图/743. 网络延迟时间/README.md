#### [743. 网络延迟时间](https://leetcode-cn.com/problems/network-delay-time/)

有 `N` 个网络节点，标记为 `1` 到 `N`。

给定一个列表 `times`，表示信号经过**有向**边的传递时间。 `times[i] = (u, v, w)`，其中 `u` 是源节点，`v` 是目标节点， `w` 是一个信号从源节点传递到目标节点的时间。

现在，我们从某个节点 `K` 发出一个信号。需要多久才能使所有节点都收到信号？如果不能使所有节点收到信号，返回 `-1`。

**示例：**

![img](https://assets.leetcode.com/uploads/2019/05/23/931_example_1.png)

```
输入：times = [[2,1,1],[2,3,1],[3,4,1]], N = 4, K = 2
输出：2
```

**注意:**

1. `N` 的范围在 `[1, 100]` 之间。
2. `K` 的范围在 `[1, N]` 之间。
3. `times` 的长度在 `[1, 6000]` 之间。
4. 所有的边 `times[i] = (u, v, w)` 都有 `1 <= u, v <= N` 且 `0 <= w <= 100`。

---

使用`Dijkstra`算法，即，迪杰斯特拉最短路径算法，采用的是一种贪心的策略

对于一个有向加权图，从某个节点`k`出发，到其可达的所有节点的最短路径：

1. 声明一个数组dis来保存源点 `s` 到各个顶点的最短距离和一个保存已经找到了最短路径的顶点的集合：T

2. 初始时，原点 s 的路径权重被赋为 0 （dis[s] = 0）。若对于顶点 s 存在能直接到达的边（s,m），则把dis[m]设为w（s, m）,同时把所有其他（s不能直接到达的）顶点的路径长度设为无穷大。初始时，集合T只有顶点s。
3. 然后，从dis数组选择最小值，则该值就是源点s到该值对应的顶点的最短路径，并且把该点加入到T中，OK，此时完成一个顶点，
   - 然后，我们需要看看新加入的顶点是否可以到达其他顶点
   - 并且看看通过该顶点到达其他点的路径长度是否比源点直接到达短，如果是，那么就替换这些顶点在dis中的值。
4. 又从dis中找出最小值，重复上述动作，直到T中包含了图的所有顶点。

最后，`dis`数组中记录的，就是可达的最短路径

参考

- [最短路径问题---Dijkstra算法详解](https://blog.csdn.net/qq_35644234/article/details/60870719)



