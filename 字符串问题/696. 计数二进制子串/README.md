#### [696. 计数二进制子串](https://leetcode-cn.com/problems/count-binary-substrings/)

给定一个字符串 `s`，计算具有相同数量0和1的非空(连续)子字符串的数量，并且这些子字符串中的所有0和所有1都是组合在一起的。

重复出现的子串要计算它们出现的次数。

**示例 1 :**

```
输入: "00110011"
输出: 6
解释: 有6个子串具有相同数量的连续1和0：“0011”，“01”，“1100”，“10”，“0011” 和 “01”。

请注意，一些重复出现的子串要计算它们出现的次数。

另外，“00110011”不是有效的子串，因为所有的0（和1）没有组合在一起。
```

**示例 2 :**

```
输入: "10101"
输出: 4
解释: 有4个子串：“10”，“01”，“10”，“01”，它们具有相同数量的连续1和0。
```

**注意：**

- `s.length` 在1到50,000之间。
- `s` 只包含“0”或“1”字符。

---

暴力解法：

```go
func countBinarySubstrings(s string) int {
	n := len(s)

	result := 0
	for i := 0; i < n; i++ {
		count0, count1 := 0, 0
		for j := i; j < n; j++ {
			if s[j] == s[i] {
				count0++
			}else if s[j] != s[i] {
				count1++
				if count0 == count1 {
					result++
				}
				if j+1 < n && s[j+1] == s[i] {
					break
				}
			}
		}
	}

	return result
}
超出时间限制
```

先将数字0，1分开，发现，如果是`001100011`时，其对于的统计数字是：

```
2,2,3,2
```

发现，符合条件的，有当前值和后一个值的最小值，即可组成一个`非空(连续)子字符串`

```
min(container[i], container[i+1])
```

总结起来，就是：

>  用一个数组v统计各段连续1或0的长度，相邻取最小值累加即可